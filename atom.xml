<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码上暴富</title>
  <icon>https://www.gravatar.com/avatar/7a0ef2db692d9e47044382fe9bc6f67b</icon>
  <subtitle>加油</subtitle>
  <link href="https://zhanghuachang.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhanghuachang.github.io/"/>
  <updated>2021-10-29T07:59:38.794Z</updated>
  <id>https://zhanghuachang.github.io/</id>
  
  <author>
    <name>zhanghuachang</name>
    <email>1786265428@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Collection-HashMap</title>
    <link href="https://zhanghuachang.github.io/2021/10/26/Collection-HashMap/"/>
    <id>https://zhanghuachang.github.io/2021/10/26/Collection-HashMap/</id>
    <published>2021-10-26T13:16:44.000Z</published>
    <updated>2021-10-29T07:59:38.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="带着问题去了解HashMap"><a href="#带着问题去了解HashMap" class="headerlink" title="带着问题去了解HashMap"></a>带着问题去了解HashMap</h3><ol><li>HashMap的结构？为什么这样设计？</li><li>hash线程安全吗？</li><li>简单介绍一下hash算法，hash冲突还有哪些解决方法？</li><li>HashMap满足什么条件会扩容？</li><li>为什么扩容的时候是2的n次幂？</li><li>get  put的过程是什么样的？</li><li>为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?</li></ol><h3 id="HashMap结构图"><a href="#HashMap结构图" class="headerlink" title="HashMap结构图"></a>HashMap结构图</h3><p><img src="/2021/10/26/Collection-HashMap/image-20211029155619054-5494180-5494222.png" alt="image-20211029155619054-5494180"></p><p>HashMap是由 <strong>数组 + 链表 + 红黑树</strong>组成的。</p><h3 id="put过程分析"><a href="#put过程分析" class="headerlink" title="put过程分析"></a>put过程分析</h3><ul><li>首次put，会触发扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 第一次put，会执行resize()，数组重null 初始化大小为16或者自定义的大小</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// p = 对应下标的node</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// 计算数组下标，如果为空，则直接放在这个位置，否则执行else</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 代表该位置有数据</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p; <span class="comment">// 判断该位置的key是否和要插入的数据相等，如果是，则取出 p 节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">// 判断是否是树节点</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">// 如果是，则调用红黑树的插值方法</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 说明该位置是链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 找到链表的尾端</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 创建node</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  TREEIFY_THRESHOLD = 8</span></span><br><span class="line">                            treeifyBin(tab, hash); <span class="comment">// 如果长度大于等于8，则转化成红黑树</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// node与要插入的值相等，则break</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// e != null，则说明存在旧值 与 要插入的值相等</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value; <span class="comment">// 进行值覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 如果新插入的值导致size超过了阈值，则进行扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="get过程分析"><a href="#get过程分析" class="headerlink" title="get过程分析"></a>get过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 判断hash后的数组下标的第一个值不为空，则返回</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); <span class="comment">// 节点是红黑树节点，则走红黑树查找逻辑</span></span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组下标计算，n为数组长度</span></span><br><span class="line"><span class="comment">// (n - 1) &amp; hash(key)</span></span><br></pre></td></tr></table></figure><h4 id="为什么hashCode的高16为与低16位做亦或运算？"><a href="#为什么hashCode的高16为与低16位做亦或运算？" class="headerlink" title="为什么hashCode的高16为与低16位做亦或运算？"></a>为什么hashCode的高16为与低16位做亦或运算？</h4><p><strong>将高低位的特征混合起来，加大低位的随机性，让结果更加散列，尽可能的减少hash冲突</strong>。</p><blockquote><p>亦或（^）运算：相同为1，相异为0</p><p>与（&amp;）运算：相同为1，相异为0</p></blockquote><p>理论上散列值是一个int，而int的hashCode的范围在**-2147483648<strong>到</strong>2147483648**，只要散列比较松散，一般很难出现冲突，但是这个将近40亿的空间内存是放不下的，因此需要对数组的长度做取模运算，得到的余数才是数组的下标，即将 数组长度  和 散列值做“与”操作 <strong>((n - 1) &amp; hash(key))</strong></p><p>通过数组下标的获取方式，刚好解释了为什么<strong>数组长度是2的n次幂</strong>，因为数组长度 - 1，正好相当于一个“低位掩码”，即低位都是1，<strong>与hashCode进行与运算，高位全部归零，结果刚好可以做数组的下标</strong></p><p><strong>因此，关键是让hash后的低位尽可能的散列，数组下标才会尽可能的平均</strong></p><h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><ul><li><p>初始化数组计算阈值 = 16 * 0.75  默认长度 * 负载因子</p></li><li><p>后续扩容，每次扩容，数组扩大一倍，阈值扩大一倍</p></li><li><p>链表数据迁移，迁移后的节点数据会组成两个链表，【原位置】 和 【原位置 + 原数组长度】</p><p>  举例说明：</p><p>  假设数组长度n = 16，</p><p>  n  -  1  = 0000 0000 0000 1111     &amp;</p><p>  hash1 = 0000 0100 1000 0110    </p><p>  hash2 = 0000 0100 1001 0110</p><p>  此时得出来的结果都是 6，因此这两个hash节点都是数组下标为6的位置</p><p>  <strong>数组扩容一倍</strong>：n = 32，如下</p><p>  n  -  1  = 0000 0000 0001 1111    &amp;</p><p>  hash1 = 0000 0100 1000 0110  </p><p>  hash2 = 0000 0100 1001 0110</p><p>  此时</p><p>  hash1 &amp; （n-1） = 6             对应代码中 loHead</p><p>  Hash2 &amp; （n-1） = 22          对应代码中  hiHead</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;   <span class="comment">// 数组扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 数组大小达到最大</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  阈值扩大一倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold  初始化指定了大小，阈值也会初始化</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults 说明是初始化没有指定大小</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  <span class="comment">// 阈值是默认长度16的0.75倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">// 初始化新的数组，后续进行数据迁移</span></span><br><span class="line">        table = newTab; <span class="comment">// 如果是初始化数组，执行到这里就结束了</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// 遍历原数组，迁移数据</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 该位置上只有一个元素，直接迁移到新数组</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 该节点是红黑树</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order 链表</span></span><br><span class="line">                        <span class="comment">// loHead [原数组下标] -&gt; 链表</span></span><br><span class="line">                        <span class="comment">// hiHead [原数组下标 + 原长度] -&gt; 链表</span></span><br><span class="line">                        <span class="comment">// 两个数组原因，由于数组扩大一倍，&amp; 运算高位多一个1，如果原来的hash值对应位置是0，则位置不变，如果为1，则位置=原数组下标 + 原长度</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 代表hash对应高位为0，则该节点位置下标不变</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;  <span class="comment">// 代表hash对应高位为1，则该节点位置下标 = 原下标位置 + 原数组长度</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>); <span class="comment">// 计算链表上元素对应下标，并组成对应位置链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;带着问题去了解HashMap&quot;&gt;&lt;a href=&quot;#带着问题去了解HashMap&quot; class=&quot;headerlink&quot; title=&quot;带着问题去了解HashMap&quot;&gt;&lt;/a&gt;带着问题去了解HashMap&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;HashMap的结构？为什么这样</summary>
      
    
    
    
    
    <category term="Java基础" scheme="https://zhanghuachang.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="集合" scheme="https://zhanghuachang.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java Debug笔记</title>
    <link href="https://zhanghuachang.github.io/2021/10/20/Java-Debug%E7%AC%94%E8%AE%B0/"/>
    <id>https://zhanghuachang.github.io/2021/10/20/Java-Debug%E7%AC%94%E8%AE%B0/</id>
    <published>2021-10-20T09:11:08.602Z</published>
    <updated>2021-10-20T09:41:22.260Z</updated>
    
    <content type="html"><![CDATA[<p><strong>日常Debug遇到的问题（持续更新…）：</strong></p><ol><li>从大量数据中找到我们需要的特定数据，比如从N次for循环中的某一个，一旦我们不小心跳过了，又需要重新循环很多次</li></ol><p><strong>举例解决如下：</strong></p><ol><li><p>右键断点处，在Condition里填写过滤条件，写法就是java的语法，如下图：</p><p> <img src="/2021/10/20/Java-Debug%E7%AC%94%E8%AE%B0/image-20211020170150162.png" alt="image-20211020170150162"></p><p> 重新运行，找出userList里name为李四的记录：</p><p> <img src="/2021/10/20/Java-Debug%E7%AC%94%E8%AE%B0/image-20211020170241683.png" alt="image-20211020170241683"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;日常Debug遇到的问题（持续更新…）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从大量数据中找到我们需要的特定数据，比如从N次for循环中的某一个，一旦我们不小心跳过了，又需要重新循环很多次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;举例解决如下：&lt;</summary>
      
    
    
    
    <category term="java" scheme="https://zhanghuachang.github.io/categories/java/"/>
    
    
    <category term="java笔记" scheme="https://zhanghuachang.github.io/tags/java%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
