{"meta":{"title":"码上暴富","subtitle":"加油","description":"这是一段描述","author":"zhanghuachang","url":"https://zhanghuachang.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-10-14T06:35:18.000Z","updated":"2021-10-14T06:35:18.661Z","comments":true,"path":"tags/index.html","permalink":"https://zhanghuachang.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-14T06:35:30.000Z","updated":"2021-10-14T06:35:30.265Z","comments":true,"path":"categories/index.html","permalink":"https://zhanghuachang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Collection-HashMap","slug":"Collection-HashMap","date":"2021-10-26T13:16:44.000Z","updated":"2021-10-29T07:59:38.794Z","comments":true,"path":"2021/10/26/Collection-HashMap/","link":"","permalink":"https://zhanghuachang.github.io/2021/10/26/Collection-HashMap/","excerpt":"","text":"带着问题去了解HashMap HashMap的结构？为什么这样设计？ hash线程安全吗？ 简单介绍一下hash算法，hash冲突还有哪些解决方法？ HashMap满足什么条件会扩容？ 为什么扩容的时候是2的n次幂？ get put的过程是什么样的？ 为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树? HashMap结构图 HashMap是由 数组 + 链表 + 红黑树组成的。 put过程分析 首次put，会触发扩容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#x27;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次put，会执行resize()，数组重null 初始化大小为16或者自定义的大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // p = 对应下标的node tab[i] = newNode(hash, key, value, null);// 计算数组下标，如果为空，则直接放在这个位置，否则执行else else &#123; // 代表该位置有数据 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断该位置的key是否和要插入的数据相等，如果是，则取出 p 节点 else if (p instanceof TreeNode) // 判断是否是树节点 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是，则调用红黑树的插值方法 else &#123; // 说明该位置是链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 找到链表的尾端 p.next = newNode(hash, key, value, null); // 创建node if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st TREEIFY_THRESHOLD = 8 treeifyBin(tab, hash); // 如果长度大于等于8，则转化成红黑树 break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // node与要插入的值相等，则break break; p = e; &#125; &#125; // e != null，则说明存在旧值 与 要插入的值相等 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 进行值覆盖 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) // 如果新插入的值导致size超过了阈值，则进行扩容 resize(); afterNodeInsertion(evict); return null; &#125; get过程分析1234567891011121314151617181920212223242526272829303132public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) // 判断hash后的数组下标的第一个值不为空，则返回 return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 节点是红黑树节点，则走红黑树查找逻辑 do &#123; // 遍历链表 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; Hash算法1234567static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// 数组下标计算，n为数组长度// (n - 1) &amp; hash(key) 为什么hashCode的高16为与低16位做亦或运算？将高低位的特征混合起来，加大低位的随机性，让结果更加散列，尽可能的减少hash冲突。 亦或（^）运算：相同为1，相异为0 与（&amp;）运算：相同为1，相异为0 理论上散列值是一个int，而int的hashCode的范围在**-2147483648到2147483648**，只要散列比较松散，一般很难出现冲突，但是这个将近40亿的空间内存是放不下的，因此需要对数组的长度做取模运算，得到的余数才是数组的下标，即将 数组长度 和 散列值做“与”操作 ((n - 1) &amp; hash(key)) 通过数组下标的获取方式，刚好解释了为什么数组长度是2的n次幂，因为数组长度 - 1，正好相当于一个“低位掩码”，即低位都是1，与hashCode进行与运算，高位全部归零，结果刚好可以做数组的下标 因此，关键是让hash后的低位尽可能的散列，数组下标才会尽可能的平均 数组扩容 初始化数组计算阈值 = 16 * 0.75 默认长度 * 负载因子 后续扩容，每次扩容，数组扩大一倍，阈值扩大一倍 链表数据迁移，迁移后的节点数据会组成两个链表，【原位置】 和 【原位置 + 原数组长度】 举例说明： 假设数组长度n = 16， n - 1 = 0000 0000 0000 1111 &amp; hash1 = 0000 0100 1000 0110 hash2 = 0000 0100 1001 0110 此时得出来的结果都是 6，因此这两个hash节点都是数组下标为6的位置 数组扩容一倍：n = 32，如下 n - 1 = 0000 0000 0001 1111 &amp; hash1 = 0000 0100 1000 0110 hash2 = 0000 0100 1001 0110 此时 hash1 &amp; （n-1） = 6 对应代码中 loHead Hash2 &amp; （n-1） = 22 对应代码中 hiHead 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 数组扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 数组大小达到最大 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold 阈值扩大一倍 &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold 初始化指定了大小，阈值也会初始化 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults 说明是初始化没有指定大小 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 阈值是默认长度16的0.75倍 &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 初始化新的数组，后续进行数据迁移 table = newTab; // 如果是初始化数组，执行到这里就结束了 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; // 遍历原数组，迁移数据 Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) // 该位置上只有一个元素，直接迁移到新数组 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 该节点是红黑树 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order 链表 // loHead [原数组下标] -&gt; 链表 // hiHead [原数组下标 + 原长度] -&gt; 链表 // 两个数组原因，由于数组扩大一倍，&amp; 运算高位多一个1，如果原来的hash值对应位置是0，则位置不变，如果为1，则位置=原数组下标 + 原长度 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; // 代表hash对应高位为0，则该节点位置下标不变 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // 代表hash对应高位为1，则该节点位置下标 = 原下标位置 + 原数组长度 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 计算链表上元素对应下标，并组成对应位置链表 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhanghuachang.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"https://zhanghuachang.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java Debug笔记","slug":"Java-Debug笔记","date":"2021-10-20T09:11:08.602Z","updated":"2021-10-20T09:41:22.260Z","comments":true,"path":"2021/10/20/Java-Debug笔记/","link":"","permalink":"https://zhanghuachang.github.io/2021/10/20/Java-Debug%E7%AC%94%E8%AE%B0/","excerpt":"","text":"日常Debug遇到的问题（持续更新…）： 从大量数据中找到我们需要的特定数据，比如从N次for循环中的某一个，一旦我们不小心跳过了，又需要重新循环很多次 举例解决如下： 右键断点处，在Condition里填写过滤条件，写法就是java的语法，如下图： 重新运行，找出userList里name为李四的记录：","categories":[{"name":"java","slug":"java","permalink":"https://zhanghuachang.github.io/categories/java/"}],"tags":[{"name":"java笔记","slug":"java笔记","permalink":"https://zhanghuachang.github.io/tags/java%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://zhanghuachang.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhanghuachang.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"https://zhanghuachang.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"java笔记","slug":"java笔记","permalink":"https://zhanghuachang.github.io/tags/java%E7%AC%94%E8%AE%B0/"}]}