{"meta":{"title":"码上暴富","subtitle":"加油","description":"这是一段描述","author":"zhanghuachang","url":"https://zhanghuachang.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-10-14T06:35:18.000Z","updated":"2021-10-14T06:35:18.661Z","comments":true,"path":"tags/index.html","permalink":"https://zhanghuachang.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-14T06:35:30.000Z","updated":"2021-10-14T06:35:30.265Z","comments":true,"path":"categories/index.html","permalink":"https://zhanghuachang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JUC-ConcurrentHashMap","slug":"JUC-ConcurrentHashMap","date":"2021-10-31T02:43:04.000Z","updated":"2021-11-09T08:36:33.406Z","comments":true,"path":"2021/10/31/JUC-ConcurrentHashMap/","link":"","permalink":"https://zhanghuachang.github.io/2021/10/31/JUC-ConcurrentHashMap/","excerpt":"","text":"[toc] 带着问题去了解ConcurrentHashMap 为什么HashTable慢？相比较ConcurrentHashMap为什么效率低下？ ConcurrentHashMap实现在JDK1.7和JDK1.8有什么不同？ ConcurrentHashMap - JDK1.7数据结构数组+（链表 或者 红黑树） 整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。 简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 Segments[]数组默认为16，不可扩容，segment关联的hashEntry[]数组可扩容 ConcurrentHashMap - JDK1.8数据结构JDK1.8ConcurrentHashMap在结构上基本和HashMap一样，但是ConcurrentHashMap为了保证安全性，需要加锁，因此源码上会复杂许多。 数组+（链表 或者 红黑树） 关键值sizeCtlsizeCtrl在多线程环境中做不同的操作时的状态，sizeCtrl是使用volatile修饰的，对所有线程可见 未初始化 等于0，表示未指定初始化容量，则使用默认容量 大于0，为指定的初始化容量 初始化中 等于-1，表示正在初始化，并且是通过cas操作的 正常状态 等于原table长度n*0.75，扩容阀值 扩容中 小于0，表示有其它线程进行扩容操作 等于(resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2表示此时只有一个线程在执行扩容 初始化123456789101112131415161718192021private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 2的30次方public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); // 如果初始化大小initialCapacity大于 2^29，那么 cap = 2^30，否则向上取最近的2^n int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap; &#125;private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; // 把数无符号右移一位后，与原数按位或，这样可以保证这个数的最高位与次高位是1，即有两位1 n |= n &gt;&gt;&gt; 2; // 由于这个数的最高位与次高位已经是1了，所以这次向右移动两位并按位或，使前四位都是1 n |= n &gt;&gt;&gt; 4; // 同理 前八位为1 n |= n &gt;&gt;&gt; 8; // 同理 前十六位为1 n |= n &gt;&gt;&gt; 16; // 同理 前32位为1 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; // n + 1，进1，则最高位变1，其余为0，结果就是2的n次方 &#125; sizeCtl = initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1，然后向上取最近的 2 的 n 次方 为什么要取initialCapacity的1.5倍 + 1的值，然后再向上取最近的2^n呢？ 因为当数组大小达到sizeCtl的0.75倍是就会扩容，这么做是防止刚初始化完成就因为需要插入的数据而作扩容操作。 （只有使用者明确要使用多大的map，才会在初始化的时候设置大小） key的计算123456789static final int spread(int h) &#123; // h = key.hashCode() return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS; // int的最大值，11111111 11111111 11111111 1111111 &#125;int index = (n - 1) &amp; spread(key.hashCode());// ^ 亦或 相同为0 相异为1// &amp; 与 两个位都为1时 才为1 否则为0 hashCode() 的高低位亦或运算，再和HASH_BITS做与运算，让hashCode高16为低16为都参与运算，加大低位的随机性，本质上使得结果更散列 相对比HashMap，hash算法为什么要 &amp; HASH_BITS？ put过程采用cas和synchronized保证线程安全。 简单说： 如果数组下标处没有节点，则采用cas方式将node放入 如果下标处有节点，则用synchronized锁住头结点，再判断链表、红黑树进行放入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public V put(K key, V value) &#123; return putVal(key, value, false); &#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); // 得到hash值 int binCount = 0; // 用于记录链表的长度 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; // 如果数组为空，则进行初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 初始化数组,下面详细说明 // 知道hash值对应的数组下标，得到第一个节点 f else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 如果数组为空 // 用一个cas操作将值放入其中即可，put操作结束 // 如果cas操作失败，则存在并发操作，进入else逻辑 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; // hash == MOVED，数组正在扩容 else if ((fh = f.hash) == MOVED) // 帮助数组迁移 tab = helpTransfer(tab, f); else &#123; // 此处逻辑说明，f 节点是该数组下标位置的头结点 V oldVal = null; // 获取数组该位置头结点的监视器锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; // 头结点的hash值大于0，则说明是链表 binCount = 1; // 用于累加，记录链表的长度 for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; // 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; // 到了链表的最末端，将这个新值放到链表的最后面 Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; // 红黑树 Node&lt;K,V&gt; p; binCount = 2; // 调用红黑树的插值方法插入新节点 if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8 if (binCount &gt;= TREEIFY_THRESHOLD) // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换 // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null; &#125; 初始化数组 初始化时的并发问题通过cas解决的 12345678910111213141516171819202122private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; if ((sc = sizeCtl) &lt; 0) // sizeCtl = -1 &lt; 0 代表有其它线程执行了初始化 Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; // 使用cas将sizeCtl设置成-1，相当于抢到了锁，执行初始化 try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; // DEFAULT_CAPACITY = 16 @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; //将数组复制给 table sc = n - (n &gt;&gt;&gt; 2); // 如果初始值到16 则 sc=12 即 0.75*n &#125; &#125; finally &#123; sizeCtl = sc; // sizeCtl = 12 &#125; break; &#125; &#125; return tab; &#125; get过程123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; // 根据hash值找到数组对应位置 int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; // 判断头结点是否就是我们需要的节点 if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) // 如果头结点的hash&lt;0 说明正在扩容，或者该位置是红黑树 //参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k） return (p = e.find(h, key)) != null ? p.val : null; // 遍历链表 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125; treeifyBins 当数组长度大于64时，才进行红黑树的转换 12345678910111213141516171819202122232425private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // 数组长度小于64，不进行红黑树转换，而是扩容操作 tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; // b是tab[index]位置的头结点 synchronized (b) &#123; // 加锁 if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; //遍历链表，建立红黑树 TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; &#125; setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); // 将红黑树放到对应位置 &#125; &#125; &#125; &#125; &#125; 扩容123456789101112131415161718192021222324252627282930313233343536373839404142private final void tryPresize(int size) &#123; // c = suze 的1.5倍 int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); int sc; while ((sc = sizeCtl) &gt;= 0) &#123; // sizeCtl &lt; 0 代表有其它线程执行扩容操作 Node&lt;K,V&gt;[] tab = table; int n; if (tab == null || (n = tab.length) == 0) &#123; n = (sc &gt; c) ? sc : c; if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; // 使用cas将sizeCtl 设置为 -1，代表该线程执行了初始化工作 try &#123; if (table == tab) &#123; @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; &#125; &#125; else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) break; else if (tab == table) &#123; int rs = resizeStamp(n);// 唯一的标识，返回一个负数 if (sc &lt; 0) &#123; // 有线程执行扩容操作 Node&lt;K,V&gt;[] nt; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break;//扩容完成，结束 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt);// 设置成功，参与线程扩容 迁移数据 &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) // (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) 最后是一个负数，设置成功表示有其它线程正在执行迁移工作 transfer(tab, null); &#125; &#125; &#125; 数据迁移: transfer参考链接：https://juejin.cn/post/6844903607901356046 计算每个线程可以处理的桶区间。默认 16. 初始化临时变量 nextTable，扩容 2 倍。 死循环，计算下标。完成总体判断。 1 如果桶内有数据，同步转移数据。通常会像链表拆成 2 份。 第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程。其实就是将一个大的迁移任务分为了一个个任务包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; // NCPU CPU核心数量，如果NCPU&lt;=1,那么只会有一个线程处理迁移 // length / 8 / 4 = 1 &lt; 16，则 stride = 16 // 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range 细分范围 if (nextTab == null) &#123; // initiating 初始化 try &#123; @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; // 扩容2倍 nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; // 扩容失败，范围溢出，使用int最大值，结束 return; &#125; nextTable = nextTab;//赋值，对其它线程可见 transferIndex = n;// 更新迁移下标，n = tab.length，老数组的长度 &#125; int nextn = nextTab.length; // 扩容2倍后的长度 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); // 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进 boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab // 死循环i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; while (advance) &#123; // 如果当前线程可以往后推进，这个循环就是控制i递减。同时，每个线程都会进入这里取得自己需要转移的桶的区间 int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; if (finishing) &#123; nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit &#125; &#125; else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123; int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://zhanghuachang.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://zhanghuachang.github.io/tags/JUC/"},{"name":"Java集合","slug":"Java集合","permalink":"https://zhanghuachang.github.io/tags/Java%E9%9B%86%E5%90%88/"}]},{"title":"Collection-HashMap","slug":"Collection-HashMap","date":"2021-10-26T13:16:44.000Z","updated":"2021-10-29T07:59:38.794Z","comments":true,"path":"2021/10/26/Collection-HashMap/","link":"","permalink":"https://zhanghuachang.github.io/2021/10/26/Collection-HashMap/","excerpt":"","text":"带着问题去了解HashMap HashMap的结构？为什么这样设计？ hash线程安全吗？ 简单介绍一下hash算法，hash冲突还有哪些解决方法？ HashMap满足什么条件会扩容？ 为什么扩容的时候是2的n次幂？ get put的过程是什么样的？ 为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树? HashMap结构图 HashMap是由 数组 + 链表 + 红黑树组成的。 put过程分析 首次put，会触发扩容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#x27;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次put，会执行resize()，数组重null 初始化大小为16或者自定义的大小 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // p = 对应下标的node tab[i] = newNode(hash, key, value, null);// 计算数组下标，如果为空，则直接放在这个位置，否则执行else else &#123; // 代表该位置有数据 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断该位置的key是否和要插入的数据相等，如果是，则取出 p 节点 else if (p instanceof TreeNode) // 判断是否是树节点 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是，则调用红黑树的插值方法 else &#123; // 说明该位置是链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 找到链表的尾端 p.next = newNode(hash, key, value, null); // 创建node if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st TREEIFY_THRESHOLD = 8 treeifyBin(tab, hash); // 如果长度大于等于8，则转化成红黑树 break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // node与要插入的值相等，则break break; p = e; &#125; &#125; // e != null，则说明存在旧值 与 要插入的值相等 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 进行值覆盖 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) // 如果新插入的值导致size超过了阈值，则进行扩容 resize(); afterNodeInsertion(evict); return null; &#125; get过程分析1234567891011121314151617181920212223242526272829303132public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) // 判断hash后的数组下标的第一个值不为空，则返回 return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 节点是红黑树节点，则走红黑树查找逻辑 do &#123; // 遍历链表 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; Hash算法1234567static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// 数组下标计算，n为数组长度// (n - 1) &amp; hash(key) 为什么hashCode的高16为与低16位做亦或运算？将高低位的特征混合起来，加大低位的随机性，让结果更加散列，尽可能的减少hash冲突。 亦或（^）运算：相同为1，相异为0 与（&amp;）运算：相同为1，相异为0 理论上散列值是一个int，而int的hashCode的范围在**-2147483648到2147483648**，只要散列比较松散，一般很难出现冲突，但是这个将近40亿的空间内存是放不下的，因此需要对数组的长度做取模运算，得到的余数才是数组的下标，即将 数组长度 和 散列值做“与”操作 ((n - 1) &amp; hash(key)) 通过数组下标的获取方式，刚好解释了为什么数组长度是2的n次幂，因为数组长度 - 1，正好相当于一个“低位掩码”，即低位都是1，与hashCode进行与运算，高位全部归零，结果刚好可以做数组的下标 因此，关键是让hash后的低位尽可能的散列，数组下标才会尽可能的平均 数组扩容 初始化数组计算阈值 = 16 * 0.75 默认长度 * 负载因子 后续扩容，每次扩容，数组扩大一倍，阈值扩大一倍 链表数据迁移，迁移后的节点数据会组成两个链表，【原位置】 和 【原位置 + 原数组长度】 举例说明： 假设数组长度n = 16， n - 1 = 0000 0000 0000 1111 &amp; hash1 = 0000 0100 1000 0110 hash2 = 0000 0100 1001 0110 此时得出来的结果都是 6，因此这两个hash节点都是数组下标为6的位置 数组扩容一倍：n = 32，如下 n - 1 = 0000 0000 0001 1111 &amp; hash1 = 0000 0100 1000 0110 hash2 = 0000 0100 1001 0110 此时 hash1 &amp; （n-1） = 6 对应代码中 loHead Hash2 &amp; （n-1） = 22 对应代码中 hiHead 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 数组扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 数组大小达到最大 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold 阈值扩大一倍 &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold 初始化指定了大小，阈值也会初始化 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults 说明是初始化没有指定大小 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 阈值是默认长度16的0.75倍 &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 初始化新的数组，后续进行数据迁移 table = newTab; // 如果是初始化数组，执行到这里就结束了 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; // 遍历原数组，迁移数据 Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) // 该位置上只有一个元素，直接迁移到新数组 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 该节点是红黑树 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order 链表 // loHead [原数组下标] -&gt; 链表 // hiHead [原数组下标 + 原长度] -&gt; 链表 // 两个数组原因，由于数组扩大一倍，&amp; 运算高位多一个1，如果原来的hash值对应位置是0，则位置不变，如果为1，则位置=原数组下标 + 原长度 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; // 代表hash对应高位为0，则该节点位置下标不变 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // 代表hash对应高位为1，则该节点位置下标 = 原下标位置 + 原数组长度 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 计算链表上元素对应下标，并组成对应位置链表 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhanghuachang.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"https://zhanghuachang.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java Debug笔记","slug":"Java-Debug笔记","date":"2021-10-20T09:11:08.602Z","updated":"2021-11-02T12:49:35.323Z","comments":true,"path":"2021/10/20/Java-Debug笔记/","link":"","permalink":"https://zhanghuachang.github.io/2021/10/20/Java-Debug%E7%AC%94%E8%AE%B0/","excerpt":"","text":"日常Debug遇到的问题（持续更新…）： 从大量数据中找到我们需要的特定数据，比如从N次for循环中的某一个，一旦我们不小心跳过了，又需要重新循环很多次 举例解决如下： 右键断点处，在Condition里填写过滤条件，写法就是java的语法，如下图： 重新运行，找出userList里name为李四的记录：","categories":[{"name":"java基础","slug":"java基础","permalink":"https://zhanghuachang.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java笔记","slug":"java笔记","permalink":"https://zhanghuachang.github.io/tags/java%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"java基础","slug":"java基础","permalink":"https://zhanghuachang.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://zhanghuachang.github.io/tags/JUC/"},{"name":"Java集合","slug":"Java集合","permalink":"https://zhanghuachang.github.io/tags/Java%E9%9B%86%E5%90%88/"},{"name":"Java基础","slug":"Java基础","permalink":"https://zhanghuachang.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"https://zhanghuachang.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"java笔记","slug":"java笔记","permalink":"https://zhanghuachang.github.io/tags/java%E7%AC%94%E8%AE%B0/"}]}